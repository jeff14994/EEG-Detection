<!DOCTYPE html>
<html>
<head>
    <title>EEG Simulator Test</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            height: 150px;
        }
        .chart-container {
            flex: 1;
            position: relative;
        }
        .data-container {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        .debug {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8d7da;
            border-radius: 4px;
            color: #721c24;
        }
        .channel-label {
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
            writing-mode: vertical-lr;
            transform: rotate(180deg);
            font-weight: bold;
        }
        .stats {
            margin-top: 10px;
            padding: 10px;
            background-color: #d1ecf1;
            border-radius: 4px;
            color: #0c5460;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>EEG Simulator Test</h1>
        <div class="status" id="connectionStatus">Connecting...</div>
        <div class="stats" id="dataStats">Data stats will appear here...</div>
        <div class="debug" id="debugInfo"></div>
        
        <div id="chartsContainer">
            <!-- Charts will be dynamically added here -->
        </div>
        
        <div class="data-container">
            <pre id="rawData"></pre>
        </div>
    </div>

    <script>
        // Simple FFT implementation
        function calculatePowerSpectrum(values) {
            // For now, return a simple amplitude spectrum as placeholder
            // This is not a true FFT but will show some data for visualization
            const n = values.length;
            const result = [];
            
            // Create some fake spectrum data based on signal variance
            // This is just for visualization until we implement a proper FFT
            let sum = 0;
            let sumSq = 0;
            
            for (let i = 0; i < n; i++) {
                sum += values[i];
                sumSq += values[i] * values[i];
            }
            
            const mean = sum / n;
            const variance = sumSq / n - mean * mean;
            
            // Generate a mock spectrum with some peaks
            for (let i = 0; i < n/2; i++) {
                // Create some artificial peaks for visualization
                const freq = i / (n / 250); // Convert bin to frequency assuming 250Hz sampling
                let power = Math.max(0.1, variance * Math.exp(-Math.pow((freq - 10)/3, 2))); // Peak around 10Hz (alpha)
                
                // Add another peak around 4Hz (theta)
                power += variance * 0.5 * Math.exp(-Math.pow((freq - 4)/2, 2));
                
                // Add another peak around 20Hz (beta)
                power += variance * 0.3 * Math.exp(-Math.pow((freq - 20)/5, 2));
                
                // Add some noise
                power += variance * 0.1 * Math.random();
                
                result.push(power);
            }
            
            return result;
        }

        // Debug information
        const debugInfo = document.getElementById('debugInfo');
        function logDebug(message) {
            const maxLines = 10;
            const lines = debugInfo.textContent.split('\n');
            if (lines.length > maxLines) {
                lines.shift();
            }
            lines.push(message);
            debugInfo.textContent = lines.join('\n');
            console.log(message);
        }

        // Configuration
        const channels = ['O1', 'O2', 'T3', 'T4'];
        const channelKeys = ['O1', 'O2', 'T3', 'T4'];
        const maxDataPoints = 2500; // 10 seconds at 250Hz
        const samplingRate = 250; // Hz
        const maxFrequency = 125; // Hz (Nyquist frequency)
        const displaySeconds = 10; // Display 10 seconds of data
        
        // Stats for data rate monitoring
        let dataCounter = 0;
        let lastTimestamp = Date.now();
        let actualSamplingRate = 0;
        
        // Update stats every second
        setInterval(() => {
            const now = Date.now();
            const elapsed = (now - lastTimestamp) / 1000;
            actualSamplingRate = dataCounter / elapsed;
            
            document.getElementById('dataStats').textContent = 
                `Receiving data at ${actualSamplingRate.toFixed(1)} Hz - Target: ${samplingRate} Hz`;
            
            dataCounter = 0;
            lastTimestamp = now;
        }, 1000);
        
        // Data storage
        const channelData = {};
        channels.forEach(channel => {
            channelData[channel] = {
                timeSeriesData: [],
                chart: null,
                spectraChart: null
            };
        });

        // Create charts container
        const container = document.getElementById('chartsContainer');
        channels.forEach((channel, idx) => {
            const row = document.createElement('div');
            row.className = 'chart-row';
            
            // Time series chart container
            const timeSeriesContainer = document.createElement('div');
            timeSeriesContainer.className = 'chart-container';
            const timeSeriesLabel = document.createElement('div');
            timeSeriesLabel.className = 'channel-label';
            timeSeriesLabel.textContent = channel;
            timeSeriesContainer.appendChild(timeSeriesLabel);
            const timeSeriesCanvas = document.createElement('canvas');
            timeSeriesContainer.appendChild(timeSeriesCanvas);
            
            // Power spectra chart container
            const spectraContainer = document.createElement('div');
            spectraContainer.className = 'chart-container';
            const spectraCanvas = document.createElement('canvas');
            spectraContainer.appendChild(spectraCanvas);
            
            row.appendChild(timeSeriesContainer);
            row.appendChild(spectraContainer);
            container.appendChild(row);
            
            // Initialize time series chart
            channelData[channel].chart = new Chart(timeSeriesCanvas, {
                type: 'line',
                data: {
                    datasets: [{
                        label: channel,
                        data: [],
                        borderColor: channel.startsWith('O') ? 'rgb(75, 192, 192)' : 'rgb(255, 99, 132)',
                        borderWidth: 1,
                        pointRadius: 0,
                        tension: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: {
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: idx === channels.length-1,
                            title: {
                                display: idx === channels.length-1,
                                text: 'Time (sec)'
                            },
                            min: 0,
                            max: displaySeconds,
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            title: {
                                display: false
                            },
                            min: -20,
                            max: 20,
                            grid: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
            
            // Initialize power spectra chart
            channelData[channel].spectraChart = new Chart(spectraCanvas, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Power',
                        data: [],
                        borderColor: channel.startsWith('O') ? 'rgb(75, 192, 192)' : 'rgb(255, 99, 132)',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            type: 'linear',
                            display: idx === channels.length-1,
                            title: {
                                display: idx === channels.length-1,
                                text: 'Frequency (Hz)'
                            },
                            min: 0,
                            max: maxFrequency,
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: {
                                display: false
                            },
                            min: 0.1,
                            grid: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        });

        // Initialize WebSocket connection
        let socket;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 1000; // 1 second

        function connectWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws/eeg_data`;
            socket = new WebSocket(wsUrl);
            logDebug('Attempting to connect to WebSocket: ' + wsUrl);
            
            socket.onopen = () => {
                logDebug('WebSocket connection established');
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionStatus').style.color = 'green';
                reconnectAttempts = 0;
            };

            socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // Count received data points
                    dataCounter++;
                    // Process the data and update charts
                    processData(data);
                } catch (error) {
                    logDebug('Error processing data: ' + error.message);
                }
            };

            socket.onerror = (error) => {
                logDebug('WebSocket error: ' + JSON.stringify(error));
                document.getElementById('connectionStatus').textContent = 'Connection Error';
                document.getElementById('connectionStatus').style.color = 'red';
            };

            socket.onclose = (event) => {
                logDebug('WebSocket connection closed. Code: ' + event.code + ', Reason: ' + event.reason);
                document.getElementById('connectionStatus').textContent = 'Disconnected';
                document.getElementById('connectionStatus').style.color = 'red';
                
                // Attempt to reconnect
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    logDebug(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                    setTimeout(connectWebSocket, reconnectDelay);
                } else {
                    logDebug('Max reconnection attempts reached. Please refresh the page.');
                }
            };
        }

        // Initial connection
        connectWebSocket();

        // Optimize chart updates by reducing update frequency
        let pendingUpdates = {};
        channels.forEach(channel => pendingUpdates[channel] = false);
        
        // Update charts at 30 fps max to reduce CPU usage
        setInterval(() => {
            channels.forEach(channel => {
                if (pendingUpdates[channel]) {
                    channelData[channel].chart.update('none');
                    channelData[channel].spectraChart.update('none');
                    pendingUpdates[channel] = false;
                }
            });
        }, 33); // ~30fps

        function processData(data) {
            const currentTime = data.timestamp % displaySeconds;
            
            // Check if we've wrapped around to a new cycle (currentTime close to 0)
            const shouldReset = currentTime < 0.1 && 
                channels.some(c => {
                    const lastPoint = channelData[c].timeSeriesData[channelData[c].timeSeriesData.length - 1];
                    return lastPoint && lastPoint.x > 9.5; // Last point was near the end of the window
                });
            
            if (shouldReset) {
                logDebug('Resetting charts for new 10-second cycle');
                // Clear all time series data
                channels.forEach(channel => {
                    channelData[channel].timeSeriesData = [];
                });
            }
            
            // Update each channel
            channels.forEach((channel, index) => {
                const value = data.data[channelKeys[index]];
                const channelInfo = channelData[channel];
                
                // Add new data point
                channelInfo.timeSeriesData.push({
                    x: currentTime,
                    y: value
                });
                
                // Keep only points in the current 10-second window
                channelInfo.timeSeriesData = channelInfo.timeSeriesData.filter(
                    point => point.x <= currentTime || (currentTime < 1 && point.x > 9)
                );
                
                // Keep only the last maxDataPoints
                if (channelInfo.timeSeriesData.length > maxDataPoints) {
                    const numToDrop = channelInfo.timeSeriesData.length - maxDataPoints;
                    channelInfo.timeSeriesData.splice(0, numToDrop);
                }
                
                // Mark for chart update
                pendingUpdates[channel] = true;
                
                // Don't update the chart here - it will be updated in the interval
                channelInfo.chart.data.datasets[0].data = channelInfo.timeSeriesData;
                
                // Calculate and update power spectra every 1/4 second (to reduce CPU usage)
                if (dataCounter % 60 === 0 && channelInfo.timeSeriesData.length >= 250) {  // Use at least 1 second of data
                    const values = channelInfo.timeSeriesData.map(d => d.y);
                    const powerSpectrum = calculatePowerSpectrum(values);
                    
                    // Calculate frequency bins
                    const frequencyBins = Array.from(
                        {length: powerSpectrum.length},
                        (_, i) => i * (samplingRate / (2 * powerSpectrum.length))
                    ).filter(f => f <= maxFrequency);
                    
                    // Create data points for the spectra
                    const spectraData = frequencyBins.map((f, i) => ({
                        x: f,
                        y: powerSpectrum[i]
                    }));
                    
                    // Update power spectra chart data
                    channelInfo.spectraChart.data.datasets[0].data = spectraData;
                }
            });
            
            // Display raw data only occasionally to reduce DOM updates
            if (dataCounter % 25 === 0) {
                document.getElementById('rawData').textContent = 
                    JSON.stringify(data, null, 2);
            }
        }
    </script>
</body>
</html> 